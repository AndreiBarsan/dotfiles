# TODO(andrei): For maximum versatility, move non-zsh stuff to a .bashrc and
# source that from here.
# 
# Handy for macOS sessions: 

# This file defines the 'module' command support on Euryale. This is a very
# brittle way of doing things, but it seems to be the only reliable way.
if [[ -f '/etc/profile.d/11-modules.sh' ]]; then
  source /etc/profile.d/11-modules.sh >/dev/null 2>&1
fi

# Module support on Ubuntu 14.04 LTS.
if [ -f /etc/profile.d/modules.sh ]; then
  source /etc/profile.d/modules.sh
fi

# Continuously refresh compinit, so we can instantly autocomplete the names of
# freshly installed packages.
zstyle ':completion:*' rehash true

# The project folder so that we can `c [tab]` to it.
export PROJECTS=~/work

# Shortcut to this dotfile's path is $ZSH.
# TODO(andrei): Is this really necessary? Isn't it just cleaner to keep
# your actual dotfile repo in 'work/dotfiles'?
if [[ -d "${HOME}/.dotfiles" ]]; then
  # I'm inconsistent on many of my machines. Plz no judge.
  export ZSH="${HOME}/.dotfiles"
else
  export ZSH="${PROJECTS}/dotfiles"
fi

# Stash local environment variables in ~/.localrc. This means they'll stay out
# of the main dotfiles repository (which is public).
if [[ -a ~/.localrc ]]; then
  source ~/.localrc
fi

# all of our zsh files
typeset -U config_files
config_files=($ZSH/**/*.zsh)

# load the path files
for file in ${(M)config_files:#*/path.zsh}; do
  source $file
done

# load everything but the path and completion files
for file in ${${config_files:#*/path.zsh}:#*/completion.zsh}; do
  source $file
done

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit

# Support bash-style autocompletion, not just zsh-style
autoload bashcompinit
bashcompinit

# load every completion after autocomplete loads
for file in ${(M)config_files:#*/completion.zsh}; do
  source $file
done

unset config_files

# Tmuxinator for neatly managing tmux sessions.
if [[ -f "${ZSH}/tmux/tmuxinator.zsh" ]]; then
  # TODO(andrei): This adds ruby deps. Strip away if too slow and stuff.
  # TODO(andrei): Fix on OS X.
  source "${ZSH}/tmux/tmuxinator.zsh"
fi

# Setup oh-my-zsh
export ZSH="$HOME/.oh-my-zsh"
plugins=(git osx zsh-syntax-highlighting conda)
ZSH_THEME="gnzh"
source "$ZSH/oh-my-zsh.sh"

# Huge command history: the interaction between these two size limits is a
# little funny, but these should go a pretty long way.
SAVEHIST=5000000
HISTSIZE=5000000

# Only disconnect if we triple C-d.
export IGNOREEOF=2

# Tweak: make sure to treat dots and slashes as word delimiters
WORDCHARS='*?_-[]~=&;!#$%^(){}<>'
bindkey -e

# Tweak: properly handle ctrl-left and ctrl-right (depends on your terminal settings)
#bindkey '^[[1;5C' forward-word
#bindkey '^[[1;5D' backward-word

# Proper character encoding
export LC_CTYPE=en_US.UTF-8

# Fuck-powered autocorrect.
# Disabled because it's been freezing up lately...
#if which thefuck >/dev/null 2>&1; then
  #eval "$(thefuck --alias)"
#fi

# Additional config parameters
if [[ -e ~/.local.bash ]]; then
  source ~/.local.bash
fi

# Job-specific stuff that shouldn't be subject to source control.
if [[ -e ~/.zshrc.job ]]; then
  source ~/.zshrc.job
fi

# export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting
export PATH="$PATH:$HOME/.local/bin"

# [OSX] iTerm2 integration (e.g. automatic theme switching depending on ssh
# host and other magic stuff).
test -e ${HOME}/.iterm2_shell_integration.zsh && source ${HOME}/.iterm2_shell_integration.zsh

# Python Anaconda support. Removing this can fix MANY weird build errors for
# seemingly unrelated projects!
#export PATH=~/anaconda3/bin:"$PATH"

# [Euler] Support modules (e.g. to do matlab command line interop)
#source /usr/local/opt/modules/Modules/init/zsh

# [OSX] Launch Matlab from the command line.
export PATH="$PATH:/Applications/MATLAB_R2015a.app/bin"

# [OSX] This adds command-line support for the Torch scientific computing framework.
# . /Users/andrei/torch/install/bin/torch-activate

# Add support for locally-installed stuff, such as Bazel.
export PATH="$PATH:$HOME/bin"
export LD_LIBRARY_PATH="$HOME/lib:$LD_LIBRARY_PATH"

# [OSX] Allow Jupyter to easily find matlab.
export MATLAB_EXECUTABLE=/Applications/MATLAB_R2015a.app/bin/matlab

# The next line updates PATH for the Google Cloud SDK.
if [ -f ~/workspace/google-cloud-sdk/path.zsh.inc ]; then
  source ~/workspace/google-cloud-sdk/path.zsh.inc
fi

# The next line enables shell command completion for gcloud on OSX.
if [ -f /Users/andrei/workspace/google-cloud-sdk/completion.zsh.inc ]; then
  source '/Users/andrei/workspace/google-cloud-sdk/completion.zsh.inc'
fi

# Support for autojump, i.e., the `j` command, which acts as a smart `cd` which
# keeps track of your most active directories.
# TODO(andrei): Make this cross-platform.
[ -f /usr/local/etc/profile.d/autojump.sh ] && . /usr/local/etc/profile.d/autojump.sh

# These lines add support for the Muse headband developer kit.
#export PATH="$PATH:/Applications/Muse"
#export DYLD_FALLBACK_LIBRARY_PATH="$DYLD_FALLBACK_LIBRARY_PATH:/Applications/Muse"

# Show the 7 most recent files when cd-ing into a dir.
#function prompt_command {
#    ls -t | head -7
#}1J
# export PROMPT_COMMAND="prompt_command"

# Protip: Can possibly customize CDPATH for EVEN MORE agility!

# CUDA 8.0 support on Ubuntu 16
export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64"
export PATH="$PATH:/usr/local/cuda-8.0/bin"

# Intel TBB (Threading Building Blocks) support on Linux for local install
# Note: it may be easier to just use the 'libtbb-dev' package.
export TBB_INSTALL_DIR="${PROJECTS}/tbbsrc"
if [[ -d "${TBB_INSTALL_DIR}" ]]; then
  RELEASE_FOLDER="${TBB_INSTALL_DIR}/build/linux_intel64_gcc_cc5.4.1_libc2.23_kernel4.4.0_release/"
  DEBUG_FOLDER="${TBB_INSTALL_DIR}/build/linux_intel64_gcc_cc5.4.1_libc2.23_kernel4.4.0_debug/"
  source "${RELEASE_FOLDER}/tbbvars.sh"
  export TBB_INCLUDE_DIRS="$TBB_INSTALL_DIR/include"
  export TBB_LIBRARY_RELEASE="$RELEASE_FOLDER"
  export TBB_LIBRARY_DEBUG="$DEBUG_FOLDER"
  export TBB_LIBRARY="$TBB_LIBRARY_RELEASE"
fi

# Autocomplete wolf commands
if $(command -v wolf >/dev/null 2>&1); then
  source <(wolf --bash-completion-script $(which wolf))
fi

# If available, start tmux, attaching to any running session.
# Tries to use tmuxinator wrapper, if available.
if [[ $(uname -s) == 'Linux' ]]; then
  # TODO(andrei): For maximum cross-platformness, PLEASE just install poweline
  # locally in '~/bin'.
  export TMUX_POWERLINE_CONF=~"/.local/lib/python2.7/site-packages/powerline/bindings/tmux/powerline.conf"
else
  export TMUX_POWERLINE_CONF="/Users/andrei/.local/lib/python3.6/site-packages/powerline/bindings/tmux/powerline.conf"
fi

if which tmuxinator >/dev/null 2>&1; then
  muxcmd="tmuxinator start cv"
else
  muxcmd="tmux"
fi

# TODO(andrei): Maybe a special var to explicitly disable auto-attaching to
# a tmux instance for, say, IDEs?
# Everything locked and loaded. Attach to tmux if we haven't already.
if which tmux >/dev/null 2>&1; then
  test -z ${TMUX} && eval "${muxcmd}"
fi
