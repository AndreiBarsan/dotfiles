# TODO(andrei): For maximum versatility, move non-zsh stuff to a .bashrc and
# source that from here.

# shortcut to this dotfiles path is $ZSH
export ZSH=$HOME/.dotfiles

# The project folder so that we can `c [tab]` to it.
export PROJECTS=~/workspace

# Stash your environment variables in ~/.localrc. This means they'll stay out
# of your main dotfiles repository (which may be public, like this one), but
# you'll have access to them in your scripts.
if [[ -a ~/.localrc ]]; then
  source ~/.localrc
fi

# all of our zsh files
typeset -U config_files
config_files=($ZSH/**/*.zsh)

# load the path files
for file in ${(M)config_files:#*/path.zsh}; do
  source $file
done

# load everything but the path and completion files
for file in ${${config_files:#*/path.zsh}:#*/completion.zsh}; do
  source $file
done

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit

# load every completion after autocomplete loads
for file in ${(M)config_files:#*/completion.zsh}; do
  source $file
done

unset config_files

# Tmuxinator for neatly managing tmux sessions.
if [[ $(uname -s) == 'Linux' ]]; then
  # TODO(andrei): This adds ruby deps. Strip away if too slow and stuff.
  # TODO(andrei): Fix on OS X.
  #source "${ZSH}/tmux/tmuxinator.zsh"
fi

# Setup oh-my-zsh
export ZSH="$HOME/.oh-my-zsh"
plugins=(git osx zsh-syntax-highlighting brew)
ZSH_THEME="gnzh"
source "$ZSH/oh-my-zsh.sh"

# Huge command history: the interaction between these two size limits is a little funny, but these should get you pretty far
SAVEHIST=500000
HISTSIZE=500000

# Only disconnect if we triple C-d.
export IGNOREEOF=2

# Tweak: make sure to treat dots and slashes as word delimiters
WORDCHARS='*?_-[]~=&;!#$%^(){}<>'
bindkey -e

# Tweak: properly handle ctrl-left and ctrl-right (depends on your terminal settings)
#bindkey '^[[1;5C' forward-word
#bindkey '^[[1;5D' backward-word

# Proper character encoding (change en_US as needed to your locale)
export LC_CTYPE=en_US.UTF-8

# Fuck-powered autocorrect
alias fuck='eval $(thefuck $(fc -ln -1 | tail -n 1)); fc -R'
alias fuck!=fuck
alias Fuck=fuck
alias Fuck!=fuck

# Additional config parameters
if [[ -e ~/.local.bash ]]; then
  source ~/.local.bash
fi

# Job-specific stuff that shouldn't be subject to source control.
if [[ -e ~/.zshrc.job ]]; then
  source ~/.zshrc.job
fi

export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting

# [OSX] iTerm2 integration (e.g. automatic theme switching depending on ssh
# host and other magic stuff).
test -e ${HOME}/.iterm2_shell_integration.zsh && source ${HOME}/.iterm2_shell_integration.zsh

# Python Anaconda support
# export PATH=~/anaconda3/bin:"$PATH"

# Support modules (e.g. to do matlab command line interop)
#source /usr/local/opt/modules/Modules/init/zsh
# [OSX] Launch Matlab from the command line.
export PATH="$PATH:/Applications/MATLAB_R2015a.app/bin"

# [OSX] This adds command-line support for the Torch scientific computing framework.
# . /Users/andrei/torch/install/bin/torch-activate

# Add support for stuff installed to '~/bin', such as Bazel.
export PATH="$PATH:$HOME/bin"

# [OSX] Allow Jupyter to easily find matlab.
export MATLAB_EXECUTABLE=/Applications/MATLAB_R2015a.app/bin/matlab

# The next line updates PATH for the Google Cloud SDK.
if [ -f /Users/andrei/workspace/google-cloud-sdk/path.zsh.inc ]; then
  source '/Users/andrei/workspace/google-cloud-sdk/path.zsh.inc'
fi

# The next line enables shell command completion for gcloud.
if [ -f /Users/andrei/workspace/google-cloud-sdk/completion.zsh.inc ]; then
  source '/Users/andrei/workspace/google-cloud-sdk/completion.zsh.inc'
fi

# Support for autojump, i.e., the `j` command, which acts as a smart `cd` which
# keeps track of your most active directories.
[ -f /usr/local/etc/profile.d/autojump.sh ] && . /usr/local/etc/profile.d/autojump.sh

# These lines add support for the Muse headband developer kit.
#export PATH="$PATH:/Applications/Muse"
#export DYLD_FALLBACK_LIBRARY_PATH="$DYLD_FALLBACK_LIBRARY_PATH:/Applications/Muse"

# Show the 7 most recent files when cd-ing into a dir.
#function prompt_command {
#    ls -t | head -7
#}
# export PROMPT_COMMAND="prompt_command"

# Protip: Can possibly customize CDPATH for EVEN MORE agility!

# ssh
# export SSH_KEY_PATH="~/.ssh/rsa_id"

# [OSX] Used by e.g., SpatialOS thingy.
# export JAVA_HOME=$(/usr/libexec/java_home)
#
#

# CUDA 8.0 support on Ubuntu 16
export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64"
export PATH="$PATH:/usr/local/cuda-8.0/bin"

# Intel TBB (Threading Building Blocks) support on Linux for local install
source ~/work/tbbsrc/build/linux_intel64_gcc_cc5.4.0_libc2.23_kernel4.4.0_release/tbbvars.sh

# If available, start tmux, attaching to any running session.
# Tries to use tmuxinator wrapper, if available.
if [[ $(uname -s) == 'Linux' ]]; then
  export TMUX_POWERLINE_CONF="/home/andrei/.local/lib/python3.5/site-packages/powerline/bindings/tmux/powerline.conf"
else
  export TMUX_POWERLINE_CONF="/Users/andrei/Library/Python/3.6/lib/python/site-packages/powerline/bindings/tmux/powerline.conf"
fi

# TODO(andrei): Tmuxinator support on OS X.
if which mux >/dev/null 2>&1; then
  muxcmd="tmuxinator start cv"
else
  muxcmd="tmux"
fi

if which tmux >/dev/null 2>&1; then
  test -z ${TMUX} && eval "${muxcmd}"

  # when quitting tmux, try to attach
  # TODO(andrei): Is this actually useful to me?
  # while test -z ${TMUX}; do
  #  tmux attach || break
  # done
fi
